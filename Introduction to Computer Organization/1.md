 1.1 [[#计算机的演变]]
 1.2 [[#计算机的层次结构]]
 1.3 [[#计算机的性能指标]]
 
 
#### 计算机的演变

PASCAL
FORTRAN

#### 计算机的层次结构

**冯诺依曼结构**：
- 存储程序的工作方式
- 运算器，控制器，存储器，输入设备，输出设备(I/O)
- 指令由操作码和地址码组成
- 存储指令和数据
	-  存储器分为==主存和外存==，其中外存可以是磁盘或者固态。主存包括==存储体，地址寄存器MAR和数据寄存器MDR==
	-  存储体由存储单元组成，存储单元由存储元件组成，存储元件是最小的存储单位，能表示==一位==二进制数。==存储字长==就是存储单元里面的==存储元件==数量。
	- MAR的位数和==存储单元==的个数有关，MAR存储着存储单元的地址，如果MAR是10位，表示存储单元有$2^{10}$个。MDR的字长一般等于存储字长。
	- CPU调取主存数据的顺序为：在MAR里存放访存地址->从存储体里找到对应的存储单元->将数据调取到MDR里面，用于响应后续的CPU运作。
	- 一条指令由==操作码==和==操作数==组成。操作码就是ADD.LOAD,STORE这些，操作数可以是地址也可以是数据。

**一个例子说明CPU存储运行原理（含主存储器版）**：

- CPU包含==控制器==和==运算器==。
- CPU的核心部件是逻辑运算单元ALU和控制单元CU

1. 编程语言转化为汇编语言:
```
1. LOAD R1, 1000h      ; 把内存地址 1000h 的值加载到 R1
2. ADD  R1, 1001h      ; 把内存地址 1001h 的值加到 R1 中
3. STORE R1, 1002h     ; 把 R1 的值存到内存地址 1002h
```
2. 初始化存储器：
```
1000h    0005h    ; 数据5
1001h    0003h    ; 数据3
1002h    ????     ; 等待被写入
```
3. 一条操作的基本流程：
	- **取指（Fetch）**
		- PC的初始值值对应主存中指令的初始位置。
	    - MAR ← PC
	    - 访问主存：MDR ← Mem[MAR]
	    - IR（Instruction Register） ← MDR
	    - PC ← PC + 1
	- **译码（Decode）**
    - 控制器解码 IR 中的操作码和操作数    
	- **执行（Execute）**
    - 根据操作码，控制器控制 ALU、寄存器、内存、总线等完成操作

上述汇编的逐条操作：
### 📌 第一步：执行 `LOAD R1, 1000h`
#### 🔸取指阶段
- PC = 0000h 
- MAR ← 0000h
- MDR ← Mem[0000h]（假设指令存储在0000h单元，内容是 `LOAD R1, 1000h`）
- IR ← MDR
- PC ← 0001h
#### 🔸译码阶段
- IR拆分操作码OP和和操作数地址（1000h）
- CU ←IR（OP），识别操作码（LOAD），目标通用寄存器（GPRs）R1
#### 🔸执行阶段
- MAR ← IR（1000h）
- MDR ← Mem[1000h] = 0005h
- R1 ← MDR = 0005h
### 📌 第二步：执行 `ADD R1, 1001h`

#### 🔸取指

- PC = 0001h 
- MAR ← 0001h
- MDR ← Mem[0001h]（ADD R1, 1001h）
- IR ← MDR
- PC ← 0002h

#### 🔸译码
- IR拆分OP和操作数
- CU ← OP
- 操作码 = ADD，地址 = 1001h，寄存器 = R1
#### 🔸执行

- MAR ← 1001h
- MDR ← Mem[1001h] = 0003h
- ALU ← R1 + MDR = 0005h + 0003h = 0008h
- R1 ← ALU = 0008h
- 标志寄存器更新（如 Z=0，S=0，C=0）
### 📌 第三步：执行 `STORE R1, 1002h`

#### 🔸取指
- PC = 0002h 
- MAR ← 0002h
- MDR ← Mem[0002h]（STORE R1, 1002h）
- IR ← MDR
- PC ← 0003h
#### 🔸译码
- 操作码 = STORE，地址 = 1002h，源寄存器 = R1  
#### 🔸执行
- MAR ← 1002h
- MDR ← R1 = 0008h
- Mem[MAR] ← MDR （ 内存地址 1002h 写入 0008h）

**源程序->可执行文件**：
- 高级语言（.c）->(预处理器) 预处理，将头文件内容插入程序(.i)->（编译器）汇编语言（.s）->操作系统->（指令集体系结构ISA）->（汇编器）机器语言（.o）->（链接器）微程序机（.exe）
**硬件和软件**：
- 软件可以由硬件代替：软件效率低，硬件效率高，两者逻辑上等效。
- 软件的分类
	- 系统软件
		- 操作系统OS
		- 数据库管理系统DBMS
		- 语言处理程序（汇编程序，编译程序，解释程序）
	- 应用软件
**计算机系统的层次结构**

	

#### 计算机的性能指标

**CPU的性能指标**
- **字长**：二进制序列又叫==字==，二进制序列的长度叫做==字长==。比如上面那个例子用16位二进制（4位16进制数）数表示数据或者地址，那么字长就是16bit，字长一般位1B（8bit）。
	- **机器字**：CPU内部用于做==整数运算==相关的寄存器中保存的==字==。比如上述例子中的R1寄存器保存了“0003h”，也就是16位二进制，那么机器字长就是16bit。
	- **指令字**：指令中包含的二进制序列。比如上述例子中IR包含的指令。
	- 指令字长一般等于存储字长。若指令字长为存储字长的两倍，那么就需要两个存储单元存储指令。也就是指令一开始存在MDR中传递给IR，如果是两倍的话那么就需要再取一次指令。
- **运算速度**：
	- **CPU时钟周期**：计算机中最小的时间单位。
	- **主频**：1秒内包含的的CPU时钟周期个数
	- **CPI（Cycle per instruction）**：一条指令需要的时钟周期数量，与主频大小无关。相当于是执行的步数。
	- **CPU执行时间**：CPU执行时间=`CPU时钟周期数*时钟周期 = CPI*指令数量*时钟周期 = COU时钟周期数量/主频 = CPI*指令数量/主频`
	- **IPS（instruction per second）**：每秒执行多少个指令。`IPS = 主频/CPI`，`MIPS = IPS/10^6`
	- **IPC（instrction per cycle）**：每个时钟周期执行多少条指令，CPI的倒数
- **主存容量**：由MAR和MDR决定，MAR的位数表明了存储单元的个数，MDR的位数表明了存储单元的字长。如果MAR为16位，那么存储单元数量位$2^{16}$个，如果MDR的位数为32位，也就是每个存储单元有32个存储元件，那么存储容量就是$2^{16}*32$位，也就是有这么多个存储元件。
- **吞吐量**：单位时间内处理的请求数量。与==系统性能==息息相关。
- **响应时间**：从请求发出到系统做出响应及获得结果所需要的==等待时间==。
- **基准测试程序**：对硬件，系统进行测试。
